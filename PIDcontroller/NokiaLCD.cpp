//************************************************************************
//*
//*				LCD_driver.c: Interface for Nokia LCD
//*
//************************************************************************
//*	Edit History
//*		<MLS>	= Mark Sproul msproul -at- jove.rutgers.edu
//************************************************************************
//*	Apr  2,	2010	<MLS> I received my Color LCD Shield sku: LCD-09363 from sparkfun
//*	Apr  2,	2010	<MLS> The code was written for WinAVR, I modified it to compile under Arduino
//*	Apr  3,	2010	<MLS> Changed SetPixel to make it "RIGHT" side up
//*	Apr  3,	2010	<MLS> Made SetPixel public
//*	Apr  3,	2010	<MLS> Working on MEGA, pin defs in nokia_tester.h
//*	Apr  4,	2010	<MLS> Removed delays from Command & Command, increased speed by 75%
//************************************************************************
#include "NokiaLCD.h"
#include <Arduino.h>
#include <WString.h>



const prog_uint8_t FONT[] PROGMEM = {
	0x08,0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
	0x00,0x63,0x63,0x63,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x36,0x36,0x7F,0x36,0x36,0x36,0x7F,0x36,0x36,0x00,0x00,0x00,0x00,
	0x0C,0x0C,0x3E,0x63,0x61,0x60,0x3E,0x03,0x03,0x43,0x63,0x3E,0x0C,0x0C,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x61,0x63,0x06,0x0C,0x18,0x33,0x63,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x1C,0x36,0x36,0x1C,0x3B,0x6E,0x66,0x66,0x3B,0x00,0x00,0x00,0x00,
	0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x0C,0x18,0x18,0x30,0x30,0x30,0x30,0x18,0x18,0x0C,0x00,0x00,0x00,0x00,
	0x00,0x00,0x18,0x0C,0x0C,0x06,0x06,0x06,0x06,0x0C,0x0C,0x18,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x42,0x66,0x3C,0xFF,0x3C,0x66,0x42,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x18,0x18,0x18,0xFF,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0x03,0x07,0x0E,0x1C,0x38,0x70,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,
	0x00,0x00,0x3E,0x63,0x63,0x63,0x6B,0x6B,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,
	0x00,0x00,0x0C,0x1C,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3F,0x00,0x00,0x00,0x00,
	0x00,0x00,0x3E,0x63,0x03,0x06,0x0C,0x18,0x30,0x61,0x63,0x7F,0x00,0x00,0x00,0x00,
	0x00,0x00,0x3E,0x63,0x03,0x03,0x1E,0x03,0x03,0x03,0x63,0x3E,0x00,0x00,0x00,0x00,
	0x00,0x00,0x06,0x0E,0x1E,0x36,0x66,0x66,0x7F,0x06,0x06,0x0F,0x00,0x00,0x00,0x00,
	0x00,0x00,0x7F,0x60,0x60,0x60,0x7E,0x03,0x03,0x63,0x73,0x3E,0x00,0x00,0x00,0x00,
	0x00,0x00,0x1C,0x30,0x60,0x60,0x7E,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,
	0x00,0x00,0x7F,0x63,0x03,0x06,0x06,0x0C,0x0C,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
	0x00,0x00,0x3E,0x63,0x63,0x63,0x3E,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,
	0x00,0x00,0x3E,0x63,0x63,0x63,0x63,0x3F,0x03,0x03,0x06,0x3C,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00,
	0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00,
	0x00,0x00,0x3E,0x63,0x63,0x06,0x0C,0x0C,0x0C,0x00,0x0C,0x0C,0x00,0x00,0x00,0x00,
	0x00,0x00,0x3E,0x63,0x63,0x6F,0x6B,0x6B,0x6E,0x60,0x60,0x3E,0x00,0x00,0x00,0x00,
	0x00,0x00,0x08,0x1C,0x36,0x63,0x63,0x63,0x7F,0x63,0x63,0x63,0x00,0x00,0x00,0x00,
	0x00,0x00,0x7E,0x33,0x33,0x33,0x3E,0x33,0x33,0x33,0x33,0x7E,0x00,0x00,0x00,0x00,
	0x00,0x00,0x1E,0x33,0x61,0x60,0x60,0x60,0x60,0x61,0x33,0x1E,0x00,0x00,0x00,0x00,
	0x00,0x00,0x7C,0x36,0x33,0x33,0x33,0x33,0x33,0x33,0x36,0x7C,0x00,0x00,0x00,0x00,
	0x00,0x00,0x7F,0x33,0x31,0x34,0x3C,0x34,0x30,0x31,0x33,0x7F,0x00,0x00,0x00,0x00,
	0x00,0x00,0x7F,0x33,0x31,0x34,0x3C,0x34,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00,
	0x00,0x00,0x1E,0x33,0x61,0x60,0x60,0x6F,0x63,0x63,0x37,0x1D,0x00,0x00,0x00,0x00,
	0x00,0x00,0x63,0x63,0x63,0x63,0x7F,0x63,0x63,0x63,0x63,0x63,0x00,0x00,0x00,0x00,
	0x00,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
	0x00,0x00,0x0F,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,
	0x00,0x00,0x73,0x33,0x36,0x36,0x3C,0x36,0x36,0x33,0x33,0x73,0x00,0x00,0x00,0x00,
	0x00,0x00,0x78,0x30,0x30,0x30,0x30,0x30,0x30,0x31,0x33,0x7F,0x00,0x00,0x00,0x00,
	0x00,0x00,0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x63,0x63,0x63,0x00,0x00,0x00,0x00,
	0x00,0x00,0x63,0x63,0x73,0x7B,0x7F,0x6F,0x67,0x63,0x63,0x63,0x00,0x00,0x00,0x00,
	0x00,0x00,0x1C,0x36,0x63,0x63,0x63,0x63,0x63,0x63,0x36,0x1C,0x00,0x00,0x00,0x00,
	0x00,0x00,0x7E,0x33,0x33,0x33,0x3E,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00,
	0x00,0x00,0x3E,0x63,0x63,0x63,0x63,0x63,0x63,0x6B,0x6F,0x3E,0x06,0x07,0x00,0x00,
	0x00,0x00,0x7E,0x33,0x33,0x33,0x3E,0x36,0x36,0x33,0x33,0x73,0x00,0x00,0x00,0x00,
	0x00,0x00,0x3E,0x63,0x63,0x30,0x1C,0x06,0x03,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,
	0x00,0x00,0xFF,0xDB,0x99,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
	0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,
	0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x36,0x1C,0x08,0x00,0x00,0x00,0x00,
	0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x6B,0x6B,0x7F,0x36,0x36,0x00,0x00,0x00,0x00,
	0x00,0x00,0xC3,0xC3,0x66,0x3C,0x18,0x18,0x3C,0x66,0xC3,0xC3,0x00,0x00,0x00,0x00,
	0x00,0x00,0xC3,0xC3,0xC3,0x66,0x3C,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,
	0x00,0x00,0x7F,0x63,0x43,0x06,0x0C,0x18,0x30,0x61,0x63,0x7F,0x00,0x00,0x00,0x00,
	0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00,
	0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x1C,0x0E,0x07,0x03,0x01,0x00,0x00,0x00,0x00,
	0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00,
	0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,
	0x18,0x18,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x3C,0x46,0x06,0x3E,0x66,0x66,0x3B,0x00,0x00,0x00,0x00,
	0x00,0x00,0x70,0x30,0x30,0x3C,0x36,0x33,0x33,0x33,0x33,0x6E,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x60,0x60,0x60,0x63,0x3E,0x00,0x00,0x00,0x00,
	0x00,0x00,0x0E,0x06,0x06,0x1E,0x36,0x66,0x66,0x66,0x66,0x3B,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x63,0x7E,0x60,0x63,0x3E,0x00,0x00,0x00,0x00,
	0x00,0x00,0x1C,0x36,0x32,0x30,0x7C,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x3B,0x66,0x66,0x66,0x66,0x3E,0x06,0x66,0x3C,0x00,0x00,
	0x00,0x00,0x70,0x30,0x30,0x36,0x3B,0x33,0x33,0x33,0x33,0x73,0x00,0x00,0x00,0x00,
	0x00,0x00,0x0C,0x0C,0x00,0x1C,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00,
	0x00,0x00,0x06,0x06,0x00,0x0E,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00,0x00,
	0x00,0x00,0x70,0x30,0x30,0x33,0x33,0x36,0x3C,0x36,0x33,0x73,0x00,0x00,0x00,0x00,
	0x00,0x00,0x1C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x6E,0x7F,0x6B,0x6B,0x6B,0x6B,0x6B,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x6E,0x33,0x33,0x33,0x33,0x33,0x33,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x6E,0x33,0x33,0x33,0x33,0x3E,0x30,0x30,0x78,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x3B,0x66,0x66,0x66,0x66,0x3E,0x06,0x06,0x0F,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x6E,0x3B,0x33,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x38,0x0E,0x03,0x63,0x3E,0x00,0x00,0x00,0x00,
	0x00,0x00,0x08,0x18,0x18,0x7E,0x18,0x18,0x18,0x18,0x1B,0x0E,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x3B,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x63,0x63,0x36,0x36,0x1C,0x1C,0x08,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x63,0x63,0x63,0x6B,0x6B,0x7F,0x36,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x63,0x36,0x1C,0x1C,0x1C,0x36,0x63,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x3F,0x03,0x06,0x3C,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x7F,0x66,0x0C,0x18,0x30,0x63,0x7F,0x00,0x00,0x00,0x00,
	0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00,
	0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,
	0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00,
	0x00,0x00,0x3B,0x6E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};


NokiaLCD* NokiaLCD::_instance = NULL;

NokiaLCD* NokiaLCD::get_Instance() {
	if(_instance==NULL) {

		_instance = new NokiaLCD();
	}
	return _instance;
}


//************************************************************************
//Usage: Clear(black);
//Inputs: char color: 8-bit color to be sent to the screen.
//Outputs: None
//Description: This function will clear the screen with "color" by writing the
//				color to each location in the RAM of the LCD.
//************************************************************************
void NokiaLCD::Clear(color_t color)
{
	unsigned int i;

#ifdef EPSON
	Command(PASET);
	Data(0);
	Data(131);

	Command(CASET);
	Data(0);
	Data(131);

	Command(RAMWR);
#endif
#ifdef	PHILLIPS
	Command(PASETP);
	Data(0);
	Data(131);

	Command(CASETP);
	Data(0);
	Data(131);

	Command(RAMWRP);
#endif

	for (i=0; i < (131*131)/2; i++)
	{
		//RG
		Data((color >> 4) & 0x00FF);
		//BR
		Data(((color & 0x0F) << 4) | (color >> 8));
		//GB
		Data(color & 0x0FF);		// nop(EPSON)
	}

	//	x_offset = 0;
	//	y_offset = 0;
}


//************************************************************************
void	NokiaLCD::delay_us(int microSecs)
{
	delayMicroseconds(microSecs);
}

//************************************************************************
void	NokiaLCD::delay_ms(int millisecs)
{
	delay(millisecs);
}


//************************************************************************
//Usage: Command(RAMWR);
//Inputs: char data - character command to be sent to the LCD
//Outputs: None
//************************************************************************
void NokiaLCD::Command(uint8_t data)
{
	char jj;
	bitClear(LCD_PORT_CS, CS);	// enable chip, p0.20 goes low		
	bitClear(LCD_PORT_SCK, LCD_SCK);	// send clock pulse
	rest();
	bitClear(LCD_PORT_DIO,DIO);		// output low on data out (9th bit low = command), p0.19
	bitSet(LCD_PORT_SCK,LCD_SCK);

	for (jj = 0; jj < 8; jj++)
	{
		bitClear(LCD_PORT_SCK,LCD_SCK);		// send clock pulse
		if ((data & 0x80) == 0x80)
		{
			bitSet(LCD_PORT_DIO,DIO);
		}
		else
		{
			bitClear(LCD_PORT_DIO,DIO);
		}
		bitSet(LCD_PORT_SCK,LCD_SCK);
		data <<= 1;
	}

	bitSet(LCD_PORT_CS,CS);			// disable
}

//************************************************************************
//Usage: Data(RAMWR);
//Inputs: char data - character data to be sent to the LCD
//Outputs: None
//************************************************************************
void NokiaLCD::Data(uint8_t data)
{
	char j;

	bitClear(LCD_PORT_CS,CS);			// enable chip, p0.20 goes low
	bitClear(LCD_PORT_SCK,LCD_SCK);	// send clock pulse
	rest();
	bitSet(LCD_PORT_DIO,DIO);			// output high on data out (9th bit high = data), p0.19
	bitSet(LCD_PORT_SCK,LCD_SCK);		// send clock pulse

	for (j = 0; j < 8; j++)
	{
		bitClear(LCD_PORT_SCK,LCD_SCK);
		if ((data & 0x80) == 0x80)
		{
			bitSet(LCD_PORT_DIO,DIO);
		}
		else
		{
			bitClear(LCD_PORT_DIO,DIO);
		}
		// send clock pulse
		bitSet(LCD_PORT_SCK,LCD_SCK);
		data <<= 1;
	}

	bitSet(LCD_PORT_CS,CS);
}

//************************************************************************
//Usage: Init();
//Inputs: None
//Outputs: None
//Description:  Initializes the LCD regardless of if the controlller is an EPSON or PHILLIPS.
//************************************************************************
void NokiaLCD::Init(void)
{
	
	//delay_ms(200);
							
	cbi(LCD_PORT_SCK, LCD_SCK);		//output_low (SPI_CLK);//output_low (SPI_DO);
	cbi(LCD_PORT_DIO, DIO);
	delay_us(10);
	sbi(LCD_PORT_CS, CS);			//output_high (LCD_CS);
	delay_us(10);
	cbi(LCD_PORT_RES, LCD_RES);		//output_low (LCD_RESET);
	delay_ms(200);
	sbi(LCD_PORT_RES, LCD_RES);		//output_high (LCD_RESET);
	delay_ms(200);
	sbi(LCD_PORT_SCK, LCD_SCK);
	sbi(LCD_PORT_DIO, DIO);
	delay_us(10);
	
	Command(DISCTL);	// display control(EPSON)
	Data(0x0C);			// 12 = 1100 - CL dividing ratio [don't divide] switching period 8H (default)
	Data(0x20);			// Duty Module 64
	Data(0x00);			// No inversion highlight on LCD
	Data(0x01);			// Non-Diperson
	
	Command(COMSCN);		// common scanning direction(EPSON)
	Data(0x00);
	
	Command(OSCON);		// internal oscialltor ON(EPSON)
	
	Command(SLPOUT);		// sleep out(EPSON)
	//Command(P_SLEEPOUT);	//sleep out(PHILLIPS)
	
	Command(VOLCTR);		// electronic volume, this is the contrast/brightness(EPSON)
	//Data(0x18);		// volume (contrast) setting - fine tuning, original
	Data(0x24);			// volume (contrast) setting - fine tuning, original
	Data(0x03);			// internal resistor ratio - coarse adjustment


	Command(PWRCTR);		// power ctrl(EPSON)
	Data(0x0F);			//everything on, no external reference resistors
	//Command(P_BSTRON);	//Booset On(PHILLIPS)
	
	Command(DISINV);		// invert display mode(EPSON)
	//Command(P_INVON);	// invert display mode(PHILLIPS)
	
	Command(DATCTL);		// data control(EPSON)
	Data(0x00);			// correct for normal sin7
	Data(0x00);			// normal RGB arrangement
	//Data(0x01);		// 8-bit Grayscale
	Data(0x02);			// 16-bit Grayscale Type A
	
	//Command(P_MADCTL);	//Memory Access Control(PHILLIPS)
	//Data(0xC8);
	
	//Command(P_COLMOD);	// Set Color Mode(PHILLIPS)
	//Data(0x02);	
	
	
	//Command(P_SETCON);	// Set Contrast(PHILLIPS)
	//(0x30);	
	
	Command(NOP);		// nop(EPSON)
	//Command(P_NOP);		// nop(PHILLIPS)
	
	delay_ms(200);

	Command(DISON);		// display on(EPSON)
	//Command(P_DISPON);	// display on(PHILLIPS)
}


//************************************************************************
//Usage: SetPixel(white, 0, 0);
//Inputs: unsigned char color - desired color of the pixel
//			unsigned char yP - Page address of pixel to be colored
//			unsigned char xP - column address of pixel to be colored
//Outputs: None
//Description: Sets the starting page(row) and column (yP & xP) coordinates in ram,
//				then writes the colour to display memory.	The ending yP & xP are left
//				maxed out so one can continue sending colour data bytes to the 'open'
//				RAMWR command to fill further memory.	issuing any red command
//				finishes RAMWR.
//**NOTE** Because this function is static, it is essentially a "private" function
//		and can only be used within this file!
//*	Apr  3,	2010	<MLS> Made SetPixel public
//************************************************************************
void NokiaLCD::SetPixel(color_t color, unsigned char xP, unsigned char yP)
{
#ifdef EPSON
	Command(PASET);	// page start/end ram
	Data(yP);
	Data(ENDPAGE);

	Command(CASET);	// column start/end ram
	Data(xP);
	Data(ENDCOL);

	Command(RAMWR);	// write
	Data((color>>4)&0x00FF);
	Data(((color&0x0F)<<4)|(color>>8));
	Data(color&0x0FF);		// nop(EPSON)		
	//Data(color);
	//Data(NOP);
	//Data(NOP);
#endif
#ifdef	PHILLIPS
	Command(PASETP);	// page start/end ram
	Data(yP);
	Data(ENDPAGE);

	Command(CASETP);	// column start/end ram
	Data(xP);
	Data(ENDCOL);

	Command(RAMWRP);	// write

	Data((unsigned char)((color>>4)&0x00FF));
	Data((unsigned char)(((color&0x0F)<<4)|0x00));
#endif

}

//************************************************************************
NokiaLCD::NokiaLCD(void)
{
	//Serial.println("LCDInit");
	////*	setup the switches for input
	//pinMode(kSwitch1_PIN, INPUT);
	//pinMode(kSwitch2_PIN, INPUT);
	//pinMode(kSwitch3_PIN, INPUT);

	////*	set the pull up resisters
	//digitalWrite(kSwitch1_PIN, HIGH);
	//digitalWrite(kSwitch2_PIN, HIGH);
	//digitalWrite(kSwitch3_PIN, HIGH);


#ifdef _USE_ARDUINO_FOR_NOKIEA_

	//*	do the LCD control lines
	pinMode(CS_PIN,			OUTPUT);
	pinMode(DIO_PIN,		OUTPUT);
	pinMode(SCK_PIN,		OUTPUT);
	pinMode(LCD_RES_PIN,	OUTPUT);

#else
	DDRB	=	((1<<CS)|(1<<DIO)|(1<<LCD_SCK)|(1<<LCD_RES));	//Set the control pins as outputs

	// USART Baud rate: 115200 (With 16 MHz Clock)
	UBRR0H	=	(MYUBRR >> 8) & 0x7F;	//Make sure highest bit(URSEL) is 0 indicating we are writing to UBRRH
	UBRR0L	=	MYUBRR;
	UCSR0A	=	(1<<U2X0);					//Double the UART Speed
	UCSR0B	=	(1<<RXEN0)|(1<<TXEN0);		//Enable Rx and Tx in UART
	UCSR0C	=	(1<<UCSZ00)|(1<<UCSZ01);		//8-Bit Characters
	//	stdout	=	&mystdout; //Required for printf init
	cli();

	// Arduino D3-5 are button pins
	// This is PD3-5
	DDRD	=	0x00;
	PORTD	=	0xFF;

	// Init timer 2
	//Set Prescaler to 8. (Timer Frequency set to 16Mhz)
	//Used for delay routines
	TCCR2B	=	(1<<CS20); 	//Divde clock by 1 for 16 Mhz Timer 2 Frequency	
#endif
}

//************************************************************************
//***                        Set line                                  ***
//************************************************************************
void NokiaLCD::DrawLine(int xP0, int yP0, int xP1, int yP1, const color_t color) {
	int dy = xP1 - xP0;// Difference between xP0 and xP1
	int dx = yP1 - yP0;// Difference between yP0 and yP1
	int stepx, stepy;
	if (dy < 0) { dy = -dy; stepy = -1; } else { stepy = 1; }
	if (dx < 0) { dx = -dx; stepx = -1; } else { stepx = 1; }
	dy <<= 1;// dy is now 2*dy
	dx <<= 1;// dx is now 2*dx
	SetPixel(color, xP0, yP0);
	if (dx > dy) {
		int fraction = dy - (dx >> 1);
		while (yP0 != yP1) {
			if (fraction >= 0) {
				xP0 += stepy;
				fraction -= dx;
			}
			yP0 += stepx;
			fraction += dy;
			SetPixel(color, xP0, yP0);
		}
	} else {
		int fraction = dx - (dy >> 1);
		while (xP0 != xP1) {
			if (fraction >= 0) {
				yP0 += stepx;
				fraction -= dy;
			}
			xP0 += stepy;
			fraction += dx;
			SetPixel(color, xP0, yP0);
		}
	}
}
//************************************************************************
//***                   Set rectangle                                  ***
//************************************************************************
void NokiaLCD::DrawRect(int xP0, int yP0, int xP1, int yP1, const bool fill, const color_t color) {
	// check if the rectangle is to be filled
	if (fill) {
		//RowSet
		Command(PASET);
		Data(yP0);
		Data(yP1);
		//Column Address set
		Command(CASET);
		Data(xP0);
		Data(xP1);
		//Set memory write mode
		Command(RAMWR);

		/*{
			char format[64];
			sprintf(format, "RECT:(%d,%d)x(%d,%d) %03x %02x %02x %02x\n", xP0,yP0,xP1,yP1, color,
				(color >> 4) & 0xFF,
				((color & 0x0F) << 4 ) | (color >> 8),
				color & 0xFF
				);
			Serial.print(format);
		}*/

		for(uint16_t i=0; i <= ((yP1-yP0+1)*(xP1-xP0+1)); i+=2) {
			//Write two pixels at a time
			//color : RGB(444)
			// data = RG(84)
			Data((color >> 4) & 0x00FF);
			// data = BR(80)
			Data(((color & 0x0F) << 4 ) | (color >> 8));
			// data = GB(40)
			Data(color & 0xFF);
		}

		//Clear
		Command(NOP);
	} else {

		// best way to draw an unfilled rectangle is to draw four lines
		DrawLine(xP0, yP0, xP1, yP0, color);
		DrawLine(xP0, yP1, xP1, yP1, color);
		DrawLine(xP0, yP0, xP0, yP1, color);
		DrawLine(xP1, yP0, xP1, yP1, color);
	}
}


//*****************************************************************************
//WriteChar.c
//Draws an ASCII character at the specified (yP,xP) address and color
//Inputs:
//c      = character to be displayed
//yP      = row address (0 .. 131)
//xP      = column address (0 .. 131)
//size   = font pitch (SMALL, MEDIUM, LARGE)
//fcolor = 12-bit foreground color value
//bcolor = 12-bit background color value
//Returns: nothing
// Author: James P Lynch, August 30, 2007
// Edited by Peter Davenport on August 23, 2010
//For more information on how this code does it's thing look at this
//"http://www.sparkfun.com/tutorial/Nokia%206100%20LCD%20Display%20Driver.pdf"
//*****************************************************************************
void NokiaLCD::WriteChar(char c, int xP, int yP, const color_t fColor, const color_t bColor) {
	//xP	=	(COL_HEIGHT-1) - xP; // make display "right" side up
	//yP	=	(ROW_LENGTH) - yP;

	int             i,j;
	unsigned char   Mask;
	unsigned int    Word0;
	unsigned int    Word1;
	uint16_t		charOffset;
	uint8_t			PixelRow;

	// get pointer to the last byte of the desired character
	charOffset = (FONT_STRIDE * (c - FONT_ASCII_OFFSET));

	// Row address set (command 0x2B)
	Command(PASET);
	Data(yP);
	Data(yP + FONT_HEIGHT - 1);
	// Column address set (command 0x2A)
	Command(CASET);
	Data(xP);
	Data(xP + FONT_WIDTH - 1);
	// WRITE MEMORY
	Command(RAMWR);
	// loop on each row, working backwards from the bottom to the top
	for (i = FONT_HEIGHT - 1; i >= 0; i--) {
		// copy pixel row from font table and then decrement row
		PixelRow = pgm_read_byte(FONT+charOffset);
		charOffset++;

		// loop on each pixel in the row (left to right)
		// Note: we do two pixels each loop
		Mask = 0x80;
		for (j = 0; j < FONT_WIDTH; j += 2) {
			// if pixel bit set, use foreground color; else use the background color
			// now get the pixel color for two successive pixels
			if ((PixelRow & Mask) == 0)
				Word0 = bColor;
			else
				Word0 = fColor;

			//Move to pixel 2
			Mask = Mask >> 1;
			if ((PixelRow & Mask) == 0)
				Word1 = bColor;
			else
				Word1 = fColor;
			Mask = Mask >> 1;
			// use this information to output three data bytes
			Data((Word0 >> 4) & 0xFF);
			Data(((Word0 & 0xF) << 4) | ((Word1 >> 8) & 0xF));
			Data(Word1 & 0xFF);
		}
	}
	// terminate the Write Memory command
	Command(NOP);
}
// *************************************************************************************************
//WriteStr.c
//
//Draws a null-terminates character string at the specified (yP,xP) address and color
//
// Inputs: pString = pointer to character string to be displayed
// yP = row address (0 .. 131)
// xP = column address (0 .. 131)
// Size = font pitch (SMALL, MEDIUM, LARGE)
// fColor = 12-bit foreground color value rrrrggggbbbb
// bColor = 12-bit background color value rrrrggggbbbb
//
// Returns: nothing
//
// Notes: Here's an example to display "Hello World!" at address (20,20)
// WriteChar("Hello World!", 20, 20, WHITE, BLACK);
//
// Author: James P Lynch, August 30, 2007
// Edited by Peter Davenport on August 23, 2010
//For more information on how this code does it's thing look at this
//"http://www.sparkfun.com/tutorial/Nokia%206100%20LCD%20Display%20Driver.pdf"
// *************************************************************************************************
void NokiaLCD::WriteStr(const char *pString, int xP, int yP, const color_t fColor, const color_t bColor) {
	//Change TopLeft Coords to Bottom right
	//yP = yP + 16;
	//xP = xP + 8;
	// loop until null-terminator is seen
	while (*pString != 0x00) {
		// draw the character
		WriteChar(*pString++, xP, yP, fColor, bColor);
		// advance the xP position
		xP = xP + 8;
		// bail out if xP exceeds 131
		if (xP > COL_HEIGHT-1) break;
	}
}

void NokiaLCD::WriteStrF(const prog_char *ifsh PROGMEM, int xP, int yP, const color_t fColor, const color_t bColor) {
	////Change TopLeft Coords to Bottom right
	//yP = yP + 16;
	//xP = xP + 8;
	const prog_char *p = ifsh;
	while (1) {
		uint8_t c = pgm_read_byte(p++);
		if (c == 0) break;
		
		// draw the character
		WriteChar(c, xP, yP, fColor, bColor);
		// advance the xP position
		xP = xP + 8;
		// bail out if xP exceeds 131
		if (xP > COL_HEIGHT-1) break;
	}
}
	




void NokiaLCD::Contrast(char setting) {
	Command(VOLCTR);        // electronic volume, this is the contrast/brightness(EPSON)
	Data(setting);			// volume (contrast) setting - course adjustment,  -- original was 24
	Data(0x03);				// internal resistor ratio - coarse adjustment
	Command(NOP);			// nop(EPSON)
}

// *************************************************************************************************
//DrawCircle
//
//Draws a full circle, half a circle, or a quarter of a circle
// Inputs:
// yPCenter the yP for the center of the circle
// xPCenter the xP for the center of the circle
// radius the radius for the circle
// color the color of the circle
// circleType the type of circle see LCD_driver.h for types of circles
//
//  This routine can be used to draw a complete circle, half circle or a quarter of a circle
//
// Returns: Nothing
//
// I found the original code at http://www.arduino.cc/playground/Code/GLCDks0108 and modified it for
// this library
//
// *************************************************************************************************
void NokiaLCD::DrawCircle (int xPCenter, int yPCenter, int radius, int color, int circleType)
{
	int yP1 = 0, xP1 = radius;
	int tSwitch = 3 - 2 * radius;

	while (yP1 <= xP1) {
		if (circleType == FULLCIRCLE||circleType == OPENSOUTH||circleType == OPENEAST||circleType == OPENSOUTHEAST) {
			//Draw NW
			SetPixel(color,xPCenter - xP1,yPCenter - yP1);
			SetPixel(color,xPCenter - yP1,yPCenter - xP1);
		}
		if (circleType == FULLCIRCLE||circleType == OPENNORTH||circleType == OPENEAST||circleType == OPENNORTHEAST) {
			//Draw SW
			SetPixel(color,xPCenter - xP1,yPCenter + yP1);
			SetPixel(color,xPCenter - yP1,yPCenter + xP1);
		}
		if (circleType == FULLCIRCLE||circleType == OPENNORTH||circleType == OPENWEST||circleType == OPENNORTHWEST) {
			//Draw SE
			SetPixel(color,xPCenter + xP1,yPCenter + yP1);
			SetPixel(color,xPCenter + yP1,yPCenter + xP1);
		}
		if (circleType == FULLCIRCLE||circleType == OPENSOUTH||circleType == OPENWEST||circleType == OPENSOUTHWEST) {
			//Draw NE
			SetPixel(color,xPCenter + xP1,yPCenter - yP1);
			SetPixel(color,xPCenter + yP1,yPCenter - xP1);
		}
		if (tSwitch < 0) {
			tSwitch += (4 * yP1 + 6);
		} else {
			tSwitch += (4 * (yP1 - xP1) + 10);
			xP1--;
		}
		yP1++;
	}
}



